This directory is for testing Kubernetes Jobs/workers using minikube.

The Goal:
 - define multiple unique workers, i.e. docker image + command
 - create a job queue
 - fill job queue and verify that the correct worker executes the job.


 Notes:

  - workers should have code on them that dequeue's only jobs of a certain label. This label can be defined in the config.
  - each worker should have all dependencies installed such that the code (or subsetting algorithm) can complete successfully.

  Approach:
   - [ ] create two simple images that perform basic computations
    - [ ] create worker image 1
    - [ ] create worker image 2
   - [ ] deploy workers using minikube
   - [ ] enqueue jobs based on the names that each worker is expecting
   - [ ] verify that the correct worker picks up and executes the job
   - [ ] generalize the worker code so that it can be adapted for many different jobs. For instance, the redis dequeuing will always be necessary and similar.



Development Notes:

    - minikube start
	- cluster: minikube
	- namespace: default

    - minikube delete
	- Deletes the local cluster. 

    - minikube dashboard
	- good for visualizing changes/configs made to the cluster

    - Get service url
	- minikube service --url web-flask
	- minikube services are not natively accessible, the command above provides a link to the local ip:port that the service is running on.
	- https://minikube.sigs.k8s.io/docs/handbook/accessing/

References

 - https://kubernetes.io/docs/tasks/job/fine-parallel-processing-work-queue/
 - https://github.com/fabric8io/jenkinshift/tree/master/vendor/k8s.io/kubernetes/examples/job/work-queue-1
 - http://louistiao.me/posts/walkthrough-deploying-a-flask-app-with-redis-queue-rq-workers-and-dashboard-using-kubernetes/
 - https://devcenter.heroku.com/articles/python-rq
